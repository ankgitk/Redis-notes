**Corrections Applied:**

*   `evic.c` → `evict.c` (Common Redis file name, likely ASR error)
*   `memm move` → `memmove`
*   `Z Malek` → `ZMalloc`
*   `dice db slash dice` → `github.com/dice-db/dice` (Standard GitHub URL format)

---

1.  **Redis Eviction Mechanism Overview:**
    *   The approximated Least Recently Used (LRU) and Least Frequently Used (LFU) algorithms are implemented in Redis's `evict.c` source file.
    *   The discussion focuses on the LRU algorithm's implementation details.

2.  **`evpoolsize` (Eviction Pool Size):**
    *   A macro `evpoolsize` is defined with a value of `16`.
    *   This constant determines the maximum size of an eviction pool, which stores sampled keys.
    *   During eviction pool population, Redis samples a batch of keys (e.g., 5 keys at a time) and pushes the best candidates (least recently used) into this pool.
    *   The worst candidate (highest idle time) from this pool of `16` elements is ultimately selected for eviction.

3.  **`getLRUClock()` Function and 24-bit Clock:**
    *   This function computes the current "LRU clock," which is a 24-bit representation of the current time.
    *   The computation involves:
        *   `ms_time()`: Gets Unix time in milliseconds.
        *   Dividing by `LRU_CLOCK_RESOLUTION` (which is `1000`) to get Unix time in seconds (epoch seconds).
        *   Bitwise ANDing (`&`) the epoch seconds with `LRU_CLOCK_MAX`.
        *   `LRU_CLOCK_MAX` is calculated as `(1 << 24) - 1`, resulting in `0xFFFFFF`, effectively taking the last 24 bits.
    *   This 24-bit clock is used to track the last access time of objects, optimizing memory usage for timestamps.

4.  **`estimateObjectIdleTime()` Function:**
    *   This function calculates the idle time of a given object based on its `last_accessed_at` timestamp and the current LRU clock.
    *   **Algorithm:**
        *   Get the `current_lru_clock` using `getLRUClock()`.
        *   If `current_lru_clock` is greater than `object->lru` (last accessed at):
            `idle_time = current_lru_clock - object->lru`
        *   Else (if `current_lru_clock` is smaller, indicating a clock wraparound):
            `idle_time = (LRU_CLOCK_MAX - object->lru) + current_lru_clock`
    *   This handles the wraparound nature of the 24-bit clock.

5.  **Eviction Pool Allocation (`evictionPoolAlloc()`):**
    *   The function that allocates the eviction pool of size `16`.
    *   This allocation happens during the `initServer()` function call, meaning the pool is initialized as soon as the Redis server boots up.
    *   It allocates a fixed-size pool to hold candidate keys for eviction.

6.  **Eviction Pool Population (`evictionPoolPopulation()`):**
    *   This function is invoked when the eviction pool is empty or lacks sufficient candidates.
    *   **Process:**
        *   Samples a batch of keys (e.g., 5 keys) from a dictionary using `dictGetSomeKeys()`.
        *   Iterates through the sampled keys.
        *   Inserts keys into the eviction pool *only if* they are "better" (i.e., worse candidates for eviction, having higher idle time) than keys already present in the pool.
    *   **Internal Data Structures (Redis's Use of Two Dictionaries):**
        *   Redis uses **two main dictionaries** internally, a significant technical "nugget":
            *   **Key Dictionary (Main Dictionary):** Stores all keys and their corresponding values.
            *   **Expires Dictionary:** Stores only keys that have an expiration time set. For these keys, it stores the key and its absolute expiration timestamp in milliseconds, but *not* the value.
        *   **Purpose of Two Dictionaries:**
            *   Optimizes operations like eviction and sampling by allowing Redis to quickly iterate over only keys with expirations, rather than scanning the entire key space.
            *   When sampling for eviction, Redis might specifically sample from the `expires` dictionary if the eviction policy dictates.

7.  **Eviction Pool Insertion Logic (Redis's `evict.c`):**
    *   The eviction pool is maintained in ascending order of idle time (worst candidates for eviction are at the end, having the most idle time).
    *   Insertion logic involves finding the correct position for a new sampled element to maintain this sorted order.
    *   If an element is to be inserted in the middle, `memmove()` is used to efficiently shift existing elements to the right, rather than a byte-by-byte loop.
    *   A new element is only inserted if it is "worse" (i.e., has a higher idle time) than the worst element currently in the pool. This ensures the pool always contains the `16` keys with the highest idle times among those sampled.
    *   The pool size never exceeds `16`.

8.  **LFU (Least Frequently Used) Algorithm in Redis:**
    *   Uses the same 24-bit LRU bits as LRU.
    *   Instead of storing `last_accessed_at`, it stores the frequency of access within those 24 bits.
    *   (Details of LFU implementation are skipped in the transcript but noted as being in `evict.c`).

9.  **`performEvictions()` Function:**
    *   This is the core function that executes the actual eviction process.
    *   It retrieves the "worst" key (the one with the highest idle time) from the end of the eviction pool.
    *   **Eviction Trigger:** Eviction is triggered when Redis's memory usage exceeds a configured `maxmemory` threshold (e.g., 1GB or 2GB).
    *   **Eviction Loop Condition:** The eviction loop continues until the amount of memory freed is greater than or equal to the `memory_to_free` (the difference between current memory usage and `maxmemory`).
    *   **Eviction Details:**
        *   Identifies the key to be evicted.
        *   Deletes the key from the corresponding dictionaries (both the main key dictionary and the expires dictionary if applicable).
        *   Triggers multiple internal hooks, such as sending notifications for key expiration/eviction and logging the information to the server log.
        *   Uses `propagateExpire` to notify other Redis components about the expiration/eviction.

10. **Redis Memory Management (`ZMalloc`):**
    *   Redis implements its own memory allocation wrapper called `ZMalloc`.
    *   `ZMalloc` wraps the standard `malloc` function in C.
    *   **Purpose:** To track the amount of memory consumed by Redis components. This is crucial for enforcing the `maxmemory` configuration, as Redis manages eviction based on total memory utilization rather than just the number of keys.

11. **Golang Re-implementation Details (Inspired by Redis):**
    *   **`object.go`:**
        *   Instead of an `expire` field, a `LastAccessedAt` field (type `uint32`) is used to store the 24-bit LRU clock value.
        *   Golang does not directly support bit fields, so `uint32` is used for simplicity, though a custom type encoding could achieve 24-bit storage.
    *   **Two Dictionaries in Go:**
        *   `store` (map): `map[string]*Object`, the main key-value store.
        *   `expires` (map): `map[*Object]uint64`, stores `Object` pointers and their absolute expiration time in milliseconds. This mimics Redis's `expires` dictionary.
    *   **`SetExpiry(obj *Object, duration_ms uint64)`:**
        *   Helper function to set an object's expiration.
        *   Calculates `expiration_time = current_unix_milliseconds + duration_ms`.
        *   Adds an entry to the `expires` map: `expires[obj] = expiration_time`.
    *   **`GetCurrentClock()`:**
        *   Returns a 24-bit resolution clock.
        *   `uint32(time.Now().Unix()) & 0xFFFFFF`.
    *   **`HasExpired(obj *Object) bool`:**
        *   Checks if an object has expired.
        *   Returns `false` if the object has no entry in the `expires` map.
        *   Otherwise, returns `true` if `expires[obj]` (absolute expiration time) is less than or equal to the current Unix milliseconds.
    *   **Key Access and Update:**
        *   `Put()` operation (update/insert): Updates `obj.LastAccessedAt` to `GetCurrentClock()`.
        *   `Get()` operation (access): If the key has not expired, updates `obj.LastAccessedAt` to `GetCurrentClock()`. If expired, triggers `Delete()`.
    *   **Deletion (`Delete()`):** Deletes the key from both the `store` (main dictionary) and the `expires` dictionary. `delete` on a non-existent map key is a no-op.

12. **Golang `eviction.go` Implementation:**
    *   **`GetCurrentClock()`:** Same 24-bit clock resolution as Redis.
    *   **`GetIdleTime()`:** Same logic as Redis, handling 24-bit clock wraparound.
    *   **`PopulateEvictionPool()`:**
        *   Samples up to 5 elements (keys) from the main store.
        *   **`EvictionPool` Structure:**
            *   `Pool`: An array of `PoolItem` (`[]PoolItem`).
            *   `KeySet`: A `map[string]struct{}` to quickly check if a key is already in the pool.
            *   `PoolItem`: A struct containing `Key` (string) and `LastAccessedAt` (uint32).
        *   **`Push()` into `EvictionPool`:**
            *   If the key already exists in `KeySet`, do nothing.
            *   Create a `PoolItem`.
            *   If `len(pool)` is less than `SIZE_MAX` (e.g., 16):
                *   Add to `KeySet`.
                *   Append to `Pool`.
            *   If no space, but the sampled element has an `IdleTime` worse than the worst element in the pool (last element after sorting):
                *   Remove the first (smallest idle time) element from the pool.
                *   Add the new item.
            *   **Sorting:** The Golang implementation *naively sorts* the entire `Pool` by `IdleTime` after every insertion using `sort.Slice()`. This is identified as a performance bottleneck in the simplified example, with an insertion sort being a more efficient alternative.
    *   **`Pop()` from `EvictionPool`:**
        *   Removes and returns the element at the 0th index (the best candidate for eviction, having the *least* idle time, assuming the pool is sorted for *eviction* not for *population*). (Correction: Based on the "worst element" logic, the sorting should be such that the worst candidate (most idle time) is at the end, and the pop should take from the end. The transcript states "picks the zeroth element" and "removes it", implying removal of the *best* candidate rather than the *worst*. This appears to be a slight inconsistency or simplification in the Go implementation's `Pop()` description compared to Redis's actual eviction strategy of picking the worst. The overall goal is to evict the *worst* candidate. If the pool is sorted ascending by idle time, the worst is at the end.)
        *   Resizes the array.

13. **Eviction Trigger and Flow in Go (`evictAllKeysLRU()`):**
    *   This function is invoked when the cache hits its `max_keys` limit (e.g., 100 keys in the Go example, differing from Redis's memory-based limit).
    *   **Process:**
        *   Calls `PopulateEvictionPool()` to fill the pool with candidates.
        *   Calculates `keys_to_be_evicted`.
        *   Loops, popping items from the `evictionPool` (which are identified as the best candidates for eviction based on idle time).
        *   For each popped item, it calls `Delete()` on the store, which removes the key from both the main store and the `expires` dictionary.
    *   This ensures that the number of keys never exceeds the configured `max_keys` limit.

14. **Graph Visualization of Key Count:**
    *   The Go implementation demonstrates that the maximum number of keys in the cache remains at `100`.
    *   When the cache reaches `100` keys, eviction is triggered, keys are removed, and the count drops (e.g., to `96`) before growing back up, illustrating the LRU eviction policy in action.