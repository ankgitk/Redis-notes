**Corrections Applied:**

*   `average CTL` â†’ `avg_ttl` (average Time To Live)

---

1.  **Eviction Strategy: All Keys Random**
    *   **Concept:** A cache eviction strategy that randomly selects keys from the entire `RedisDB` (or custom database) to remove when the storage limit is reached.
    *   **Implementation Overview:**
        *   Triggered when the `keys_limit` (maximum number of keys) is exceeded.
        *   The number of keys to evict (`evict_count`) is calculated as `total_number_of_keys` * `eviction_ratio`.
        *   Iteration through the internal `hash table` is performed.
        *   The `delete` operation is invoked on `evict_count` number of keys during this iteration.
    *   **Randomness Mechanism:**
        *   Relies on the "randomness" of the underlying `hash table` iteration order, specifically in Golang's implementation.
        *   When a key is inserted, it's passed through a `hash function`, determining its slot in the hash table.
        *   Since the `hash function` output is unpredictable, the distribution of keys across slots is treated as "fairly random," which then influences the iteration order, providing a pseudo-random eviction.
    *   **`keys_limit`:** A configurable threshold (e.g., 100 keys) defining the maximum capacity of the database.
    *   **`eviction_ratio`:** A demonstration-specific parameter (e.g., 0.4 or 40%) that dictates the percentage of keys to evict when an eviction is triggered. In production, this would typically be a much smaller percentage (e.g., 5-10 keys).
    *   **File:** The implementation is found in the `eviction.go` file.

2.  **Database Statistics and Monitoring**
    *   **Purpose:** Essential for monitoring database health, setting up alerts, ensuring transparency, and confirming database functionality.
    *   **Redis `INFO` Command:**
        *   A core `Redis` command used to retrieve point-in-time statistics about the database.
        *   Returns information classified into multiple sections.
        *   **Format:** Each section starts with a title (e.g., `# Key Space`), followed by a newline, and then `key:value` pairs, each terminated by `\r\n`.
        *   **Example `Key Space` section format:**
            ```
            # Key Space
            db0:keys=1,expires=0,avg_ttl=0
            db1:keys=0,expires=0,avg_ttl=0
            ```
        *   **Key metrics of interest:** `keys` (number of keys in a specific database, e.g., `db0`). `expires` and `avg_ttl` (average Time To Live) are typically less relevant for basic key count monitoring.
    *   **Sections in `INFO`:**
        *   `Key Space`: Provides per-database key count and expiration statistics.
        *   `Server Metrics`: Includes information like `Redis` version, memory consumption, cache miss ratio, etc.
    *   **Limitations of `INFO`:** Provides only point-in-time statistics, not historical trends.

3.  **Visualization Stack for Historical Data**
    *   To visualize historical database statistics and trends, a stack of tools is used:
        *   **`Grafana`:** A visualization tool for plotting charts and dashboards to observe database performance over time.
        *   **`Prometheus`:** A time-series database designed to pull data from various sources and store it. It stores data in a format `Grafana` can understand.
        *   **`Redis exporter`:** A `Prometheus` plugin/exporter that continuously:
            *   Fires the `INFO` command against a `Redis`-compliant database (like `DiceDB`).
            *   Collects the metrics returned by `INFO`.
            *   Exposes these metrics on an endpoint for `Prometheus` to scrape.
    *   **Integration:** `Prometheus` scrapes data from the `Redis exporter`, stores it, and `Grafana` then queries `Prometheus` to render historical graphs.
    *   **`DiceDB` Compliance:** The custom database (`DiceDB`) implements the `INFO` command to export information in the *exact same format* as `Redis`, allowing existing `Redis exporter` and other `Redis` tooling to be reused without modification.

4.  **`DiceDB` Implementation Details (Stats)**
    *   **`eval` file:** Defines and implements database commands, including the `info` command.
    *   **`info` Command Logic:**
        *   Creates a `buffer` to construct the response.
        *   Writes the `Key Space` section header (`# Key Space\r\n`).
        *   Iterates through database statistics (`key_space_stats`) to append `dbX:keys=Y,expires=0,avg_ttl=0` for each database.
        *   The database numbers (`db0`, `db1`, etc.) range from `db0` to `db3` in this small implementation (whereas `Redis` supports `db0` to `db15`).
    *   **`key_space_stats` Object:**
        *   A global object (e.g., `map[string]map[string]int` representing `DB_ID -> Metric_Name -> Value`) that stores current statistics for each database.
        *   Example: `key_space_stats[0]["keys"]` would store the number of keys in `db0`.
    *   **`update_DB_stat` Function:** A function exposed to update metrics for a specific database (`DB_ID`) and metric (`Metric_Name`) with a given `Value`.
    *   **`store` file:** Handles key storage operations.
        *   **Key Insertion (`PUT`):** When an object (key-value pair) is inserted, `key_space_stats[0]["keys"]` is incremented (`++`).
        *   **Key Deletion (`DELETE`):** When an object is deleted, `key_space_stats[0]["keys"]` is decremented (`--`).
        *   This ensures the `key_space_stats` global dictionary always reflects the current number of keys in the database.
    *   **Client Response:** The `info` command response is sent to the client in a bulk string format.

5.  **Demonstration and Sawtooth Pattern**
    *   **Setup:**
        *   `DiceDB` running on port `7379`.
        *   `Redis CLI` connects to `DiceDB` (`redis-cli -p 7379`).
        *   `Grafana` instance is running to visualize metrics.
    *   **`storm` Utility:** A custom utility (`go run storm set main.go`) that continuously bombards `DiceDB` with random `SET` requests, simulating high write load.
    *   **Observed Behavior:**
        *   When `storm` bombards the DB, the number of keys initially increases in `Grafana`.
        *   Upon reaching the `keys_limit` (e.g., 100), the `all keys random` eviction strategy triggers.
        *   Because `eviction_ratio` is set to 40%, 40% of the keys are evicted, causing a sharp drop in the number of keys.
        *   The process repeats, with keys increasing again, hitting the limit, and then dropping, creating a characteristic **sawtooth pattern** on the `Grafana` chart.
        *   The maximum number of keys never exceeds the `keys_limit` (100) despite continuous bombardment.
    *   **`eviction_ratio` Impact:** A higher `eviction_ratio` (like 40%) results in a clearer, sharper sawtooth pattern, making the eviction visually evident. A smaller ratio (e.g., 5-10%) would show less dramatic fluctuations.

6.  **Future Topics (Next Videos)**
    *   **Approximated LRU Algorithm:**
        *   Detailed theoretical understanding of how `Redis` implements its Least Recently Used (LRU) algorithm.
        *   Reference to `LRU bits` (24 bits) seen in `Redis object` structure, which are used for this approximation.
        *   Subsequent video will involve implementing this algorithm by studying actual `Redis` source code.
        *   This algorithm is noted for being efficient at scale and simple to implement.