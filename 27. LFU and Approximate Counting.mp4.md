**Corrections Applied:**
*   `evic.c` â†’ `evict.c`

---

1.  **Redis Eviction Strategies:** Redis supports multiple strategies for evicting keys when memory is full.
    *   **LRU (Least Recently Used):** Evicts the key that has not been accessed for the longest time.
    *   **LFU (Least Frequently Used):** Evicts the key that has been accessed the fewest number of times.

2.  **LFU Eviction Mechanism:**
    *   Requires tracking the frequency of access for each key.
    *   Employs **approximate counting** to store frequency information efficiently due to memory constraints, rather than standard integer increments.

3.  **Storage for LFU Data in Redis:**
    *   Redis reuses the 24 bits initially designated for LRU tracking within the Redis object structure for LFU implementation.
    *   These 24 bits are divided into two parts:
        *   **16 bits:** Store the **last decrement time**. This helps in decaying the access count over time.
        *   **8 bits:** Store the **logarithmic counter**, representing the access frequency.

4.  **Time Decay for LFU:**
    *   A naive approach of simply incrementing a counter indefinitely for frequently accessed keys would lead to incorrect eviction decisions (e.g., keeping a key that was initially popular but is now idle).
    *   To address this, the access count needs to decay over time. This is achieved by incorporating time-based logic into the LFU mechanism.

5.  **Logarithmic Counter (8 bits):**
    *   This component aims to store access frequency using only 8 bits, allowing for counts higher than 255.
    *   It employs an **approximate counting algorithm**, specifically a variation of the **Morris counter**.
    *   Instead of storing the actual count `N`, it stores a function of the count, `V = log(1 + N)`. This logarithmic mapping:
        *   Provides higher precision for smaller frequency values (e.g., distinguishing between 1, 2, and 5 accesses is crucial).
        *   Allows for lower precision for very large frequency values (e.g., the difference between 1 million and 1.01 million accesses is less significant).
        *   This is a space-efficient strategy for representing a wide range of frequencies.

6.  **Morris Counter Implementation Details:**
    *   **Incrementing `V`:** Directly incrementing `V` on every access is not feasible due to the limited range of 8 bits and the nature of the logarithmic function.
    *   **Cost Metric:** The decision to increment `V` is probabilistic, based on the "cost" of inaccuracy. The cost is related to the difference in estimated actual count (`N`) if `V` is incremented versus if it's not.
    *   **Probability `d`:** A metric `d` is calculated as `1 / (N(V+1) - N(V))`, where `N(V)` is the estimated actual count from the stored value `V`. A smaller difference means `d` is larger, implying a higher cost of incrementing `V`.
    *   **Probabilistic Increment:** A random number `r` is generated. If `d` is greater than `r` (or equivalently, if `r` is less than `d`), `V` is incremented. This ensures that increments are more likely when the estimated count `N` is small, and less likely when `N` is large.
    *   **Morris's Tweak:** Morris's original algorithm for the counter might use `log_2(N+1)` or `log_2(N+1)/log_2(base)` instead of `log(1+N)`. Redis uses a variant of this.

7.  **Last Decrement Time (16 bits):**
    *   Stores the **Unix timestamp in minutes** when the counter was last decremented or adjusted.
    *   Only the least significant 16 bits of the Unix time in minutes are stored, which limits the timestamp range.
    *   This field is crucial for calculating how much time has elapsed since the last access, informing the decay process.

8.  **LFU Time Elapsed Calculation:**
    *   When a key is accessed, the elapsed time since its last recorded decrement time (`LDT`) is calculated.
    *   This is similar to LRU's elapsed time calculation, handling wrap-around scenarios for the 16-bit timestamp.
    *   The calculation involves `now_time - LDT` or, if wrap-around occurs, `(max_16_bit_value - LDT) + now_time`.

9.  **Redis LFU Decay Process:**
    *   **Decay Interval:** A configuration parameter, `LFU_DECAY_TIME`, typically set to 1 minute, defines the interval at which the access count decays.
    *   **Decay Logic:** For every `LFU_DECAY_TIME` interval that has elapsed since the last access, the access counter (`V`) is effectively decremented by one.
    *   **Runtime Adjustment:** The decay is not managed by a background thread. Instead, it's calculated **on-the-fly** whenever a key is accessed. The function `LFU_DECREMENT_AND_RETURN` calculates the number of decay periods (`num_periods = time_elapsed / decay_time`) and returns an adjusted counter value (`max(0, current_counter - num_periods)`). This adjusted value is then used as the base for incrementing due to the current access.
    *   **Exponential Decay:** Due to the logarithmic nature of `V`, decrementing `V` by 1 corresponds to halving the estimated actual frequency `N` (when `N` is large). This results in an exponential decay of the perceived access frequency.

10. **Redis LFU Saturation:**
    *   The logarithmic counter saturates at a maximum estimated frequency of 1 million accesses.
    *   This is a practical limit, as precision beyond this value is often not critical for eviction decisions.

11. **Updating LFU Counter on Access:**
    *   The `updateLfu` function in `db.c` is invoked upon every key access if LFU eviction is enabled.
    *   It first calls `LFU_DECREMENT_AND_RETURN` to get the effective counter value after decay.
    *   Then, it increments this value because the key has just been accessed.
    *   Finally, it reconstructs the 24-bit LRU field:
        *   The current Unix time in minutes (least significant 16 bits) is stored in the first 16 bits.
        *   The incremented logarithmic counter value (8 bits) is OR-ed with the time component and stored in the 24-bit LRU field.

12. **Source Code Location:** The LFU implementation details can be found in `evict.c`.

13. **Optimization:** The LFU implementation is highlighted as a "beautiful piece of implementation" that is highly optimized for space, using a fraction of memory while performing complex tasks without significant error. This demonstrates the power of approximate algorithms.